<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Domoticz-MQTT Mapper Generator</title>
  <style>
    body { 
		font-family: sans-serif; 
		margin: 2rem; 
		background: #FFFFFF;
		line-height: 1 }
 
	form > div, fieldset { margin-bottom: 0.5rem; } 
	label { display: block; margin-bottom: 0.5rem; } 
	input, select, button { font-size: 1rem; padding: 0.4rem; margin-top: 0.2rem; } 
	select, input[type="text"] { width: 100%; max-width: 400px; } 
	fieldset { border: 1px solid #ccc; padding: 1rem; } 
	legend { font-weight: bold; } 
	.entry { border: 1px dashed #aaa; padding: 1rem; margin-bottom: 1rem; position: relative; } 
	.removeEntryBtn { position: absolute; top: 1rem; right: 1rem; background: #e74c3c; color: white; border: none; cursor: pointer; padding: 0.2rem 0.5rem; } 
	#messages, #output { background: #f7f7f7; padding: 1rem; border: 1px solid #ddd; white-space: pre-wrap; word-wrap: break-word; } 
	#messages { max-height: 150px; overflow-y: auto; } 
	/* template hidden */ 
	#templateContainer { display: none; }

    /* Debug-logpanel */
    #debugLog {
      display: none;
      background: #eef;
      border: 1px solid #99f;
      padding: 0.5rem;
      margin-bottom: 1rem;
      max-height: 120px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9rem;
    }
    /* All  readonly inputs lightgray */
    input[readonly] {
         background-color: #eee;
         }
    /* Header and toggle-button */
	.entry-header {
		display: flex;
		align-items: center;
		background: #f9f9f9;
		padding: 0.5rem;
		border-bottom: 1px solid #ddd;
		cursor: pointer;
	}

	.toggleEntryBtn {
		font-size: 1.2rem;
		margin-right: 0.5rem;
	}

	/* At collapsed: Hide all fields except Name */
	.entry.collapsed .entry-body {
		display: none;
	}

	/* Optional: turn the icon at collapsed */
	.entry.collapsed .toggleEntryBtn {
		transform: rotate(90deg);
	}

  </style>
</head>
<body>
  <h1>Domoticz-MQTT Mapper Generator</h1>
  
	<!-- Debug toggle and panel -->
  <div style="margin-bottom:1rem;">
    <label><input type="checkbox" id="debugToggle"> Debug</label>
  </div>
  <div id="debugLog"></div>

  <form id="configForm">
    <div>
      <strong>Broker:</strong>
      <span id="brokerInfo">{{ broker_host }}:{{ broker_port }}</span>
    </div>

    <div id="templateContainer">
      <label for="topicSelect">Alle topics
        <select id="topicSelect" disabled>
          <option>— wacht op berichten —</option>
        </select>
      </label>
    </div>

    <fieldset id="mappingSection">
      <legend>Mappings</legend>
      <button type="button" id="addEntryBtn" disabled>Add entry</button>
    </fieldset>

    <button type="button" id="generateBtn" disabled>Generate JSON</button>
  </form>

  <h2>Received MQTT-messages</h2>
  <ul id="messages"></ul>

  <h2>Result JSON</h2>
  <pre id="output">{ }</pre>
	<script>

	// Debug‐helpers
    const debugToggle = document.getElementById('debugToggle');
    const debugLogEl  = document.getElementById('debugLog');
    // remember debug status in localStorage
    const DEBUG = localStorage.getItem('debug') === 'true';
    debugToggle.checked = DEBUG;
    if (DEBUG) debugLogEl.style.display = 'block';

    debugToggle.addEventListener('change', e => {
      const on = e.target.checked;
      localStorage.setItem('debug', on);
      debugLogEl.style.display = on ? 'block' : 'none';
      logDebug(`Debug mode ${on ? 'aan' : 'uit'}`);
    });

    function logDebug(msg) {
      if (!debugToggle.checked) return;
      console.debug('[DEBUG]', msg);
      const time = new Date().toISOString().substr(11, 8);
      const line = document.createElement('div');
      line.textContent = `[${time}] ${msg}`;
      debugLogEl.appendChild(line);
      debugLogEl.scrollTop = debugLogEl.scrollHeight;
    }
    // Globale state
    let domoticzDTypes = {};
    let mappingJson = {};
    let typeOptionsHtml = '';
    let entryCount = 0;
    const topicsSet = new Set();

    const msgList   = document.getElementById('messages');
    const topicSel  = document.getElementById('topicSelect');
    const addBtn    = document.getElementById('addEntryBtn');
    const genBtn    = document.getElementById('generateBtn');
    const mappingSec = document.getElementById('mappingSection');

    // SSE: update received messages, topics- & entries
    const evtSource = new EventSource('/events');
    evtSource.onmessage = e => {
      const { topic, payload } = JSON.parse(e.data);
      if (!topicsSet.has(topic)) {
        addTopicOption(topic);
        enableButtons();
      }
      updateEntries(topic, payload);
      logMessage(topic, payload);
    };
    evtSource.onerror = () => { console.error('SSE broken'); evtSource.close(); };

    // Helper: topic-option
    function addTopicOption(topic) {
      topicsSet.add(topic);
      const opt = document.createElement('option');
      opt.value = topic;
      opt.text  = topic;
      topicSel.appendChild(opt);
      document.querySelectorAll('select[name="topic"]')
              .forEach(sel => sel.appendChild(opt.cloneNode(true)));
    }

    function enableButtons() {
      if (topicsSet.size > 0) {
        addBtn.disabled = false;
        genBtn.disabled = false;
      }
    }

    // Helper: update "latestPayload" in existing entries
    function updateEntries(topic, payload) {
      document.querySelectorAll('.entry').forEach(entry => {
        if (entry.querySelector('select[name="topic"]').value === topic) {
          entry.querySelector('input[name="latestPayload"]').value = payload;
        }
      });
    }

    function logMessage(topic, payload) {
      const li = document.createElement('li');
      li.textContent = `${topic}: ${payload}`;
      msgList.appendChild(li);
      msgList.scrollTop = msgList.scrollHeight;
    }
    // Helper: show nValue, sValue, dtype, subtype hints based on chosen Device
    // Needs to be improved for multiple sValue devices.
    function fillTypeFields(container, typeId) {
	  logDebug(`fillTypeFields() aangeroepen with typeId=${typeId}`);
      const def = domoticzDTypes[typeId] || {};
      const dtp = container.querySelector('input[name="dtype"]');
      const stp = container.querySelector('input[name="subtype"]');
      const nIn = container.querySelector('input[name="nValue"]');
      const sIn = container.querySelector('input[name="sValue"]');
      parts  = typeId.split('/');
      
      nIn.value = def.nValue && Object.keys(def.nValue).length
        ? JSON.stringify(def.nValue) : 'not specified';
      sIn.value = def.sValue && Object.keys(def.sValue).length
        ? JSON.stringify(def.sValue) : 'not specified';
      dtp.value =  parts[0];
      stp.value =  parts[1];
        
    }
	function collapseEntry(div) {
	  div.classList.add('collapsed');
	  const btn = div.querySelector('.toggleEntryBtn');
	  if (btn) btn.textContent = '▶';
	}

    // Start with loading device types 
	fetch('{{ url_for("project_assets", filename="DomoticzTypes.json") }}')
	  .then(r => r.json())
	  .then(json => {
		domoticzDTypes   = json.definitions;
		buildTypeOptions(); // build List of values for UI
		// only after buildTypeOptions load mapping json
		return fetch('{{ url_for("project_assets", filename="example.json") }}');
	  })
	  .then(r => {
		if (!r) return null;         // in case of failed types-fetch
		if (!r.ok) {
		  logDebug(`No mapping json found (status ${r.status})`);
		  return null;
		}
		return r.json();
	  })
	  .then(mappingData => {
		if (mappingData) {
		  mappingJson = mappingData;
		  buildFromMapping();
		}
	  })
	  .catch(err => {
		console.error('Error at loading data:', err);
	  });
		
	function buildTypeOptions() {
      typeOptionsHtml = '<option value="">Select device type…</option>';
      //logDebug(`buildTypeOptions() called with data=${JSON.stringify(domoticzDTypes)}`);
      logDebug(`buildTypeOptions() aangeroepen`);
      Object.entries(domoticzDTypes).forEach(([id, def]) => {
        typeOptionsHtml +=
          `<option value="${id}">${def.typeName}/${def.subTypeName} (${id})</option>`;
      });
    }

    // Build entries from loaded mapping json
    function buildFromMapping() {
	  logDebug(`buildFromMapping() called`);
      Object.entries(mappingJson).forEach(([name, def]) => {
        // add topic automatically
        if (!topicsSet.has(def.topic)) {
          addTopicOption(def.topic);
        }
        // create the entry with values
        const newentry = createEntry({
          topic:      def.topic,
          name:       name,
          dtype:      def.type,
          subtype:    def.subtype,
          switchtype: def.switchtype,
          options:    JSON.stringify((def.options) || '').replace(/"/g, '&quot;'),
          set:        JSON.stringify((def.set) || '').replace(/"/g, '&quot;'),
          mapping:    JSON.stringify(def.mapping).replace(/"/g, '&quot;')
        });
        collapseEntry(newentry); 
        //collapse by default.
      });
      enableButtons();
    }

	function createEntry(data = {}) {
	  entryCount++;
	  const div = document.createElement('div');
	  div.className = 'entry';

	  // Template met header + body wrapper
	  div.innerHTML = `
		<div class="entry-header">
		  <span class="toggleEntryBtn">▶</span>
		  <h3>Mapping ${entryCount}</h3>
		  <!-- Name always stays visible -->
		  <label style="margin-left:auto;">
			Naam
			<input type="text" name="name" required value="${data.name||''}">
		  </label>
		  <button class="removeEntryBtn" type="button">&times;</button>
		</div>
		<div class="entry-body">
		  <label>
			Topic
			<select name="topic" required>${topicSel.innerHTML}</select>
		  </label>
		  <label>
			Last Payload
			<input type="text" name="latestPayload" readonly placeholder="wait for new message">
		  </label>
		  <label>
			Type
			<select name="type" required>${typeOptionsHtml}</select>
		  </label>
		  <div>
			<label style="display:inline-block">
			  dtype <input type="text" name="dtype" readonly style="width:40px" value="${data.dtype||''}">
			</label>
			<label style="display:inline-block">
			  subtype <input type="text" name="subtype" readonly style="width:40px" value="${data.subtype||''}">
			</label>
			<label style="display:inline-block">
			  switchtype <input type="text" name="switchtype" style="width:40px" value="${data.switchtype||''}">
			</label>
		  </div>
		  <label>
			options (json)
			<input type="text" name="options" value="${data.options||''}">
		  </label>
		  <label>
			set (json)
			<input type="text" name="set" value="${data.set||''}">
		  </label>
		  <label>
			nValue (numeric)
			<input type="text" name="nValue" readonly>
		  </label>
		  <label>
			sValue (string)
			<input type="text" name="sValue" readonly>
		  </label>
		  <label>
			Mapping (payload-pad)
			<input type="text" name="mapping" required placeholder='example: {"item":"value"}' value="${data.mapping||''}">
		  </label>
		</div>
	  `;

	  // Event listener for remove button
	  div.querySelector('.removeEntryBtn').addEventListener('click', () => div.remove());

	  // Set default topic as given
	  if (data.topic) {
		div.querySelector('select[name="topic"]').value = data.topic;
	  }

	  // Toggle collapse/expand
	  const header = div.querySelector('.entry-header');
	  const toggleBtn = header.querySelector('.toggleEntryBtn');
	  header.addEventListener('click', () => {
		div.classList.toggle('collapsed');
		// Rotate arrow
		toggleBtn.textContent = div.classList.contains('collapsed') ? '▶' : '▶';
	  });

	  // DeviceType-choice event en prefill
	  const typeSel = div.querySelector('select[name="type"]');
	  typeSel.addEventListener('change', e => fillTypeFields(div, e.target.value));
	  if (data.type) {
		typeSel.value = data.type;
		logDebug(`call fillTypeFields() for Type`);
		fillTypeFields(div, data.type);
	  } 
	  if (data.dtype) {
		const syntheticType = `${data.dtype}/${data.subtype}`;
		typeSel.value = syntheticType;
		logDebug(`call fillTypeFields() for dtype`);
		fillTypeFields(div, syntheticType);
	  }

	  // Reserved for Add entry-button
	  mappingSec.insertBefore(div, addBtn);
	  return div;
	}

    // Add entry button
    addBtn.addEventListener('click', () => createEntry());

    // Generate new mapping-JSON
    //Todo: save the file.
	genBtn.addEventListener('click', () => {
	  logDebug('generate json called');
	  const mappings = [];

	  document.querySelectorAll('.entry').forEach(entry => {
		const topicVal = entry.querySelector('select[name="topic"]').value;
		const name     = entry.querySelector('input[name="name"]').value.trim();
		const typeId   = parseInt(entry.querySelector('select[name="type"]').value, 10);

		const optInput = entry.querySelector('input[name="options"]');
		const setInput = entry.querySelector('input[name="set"]');
		const mapInput = entry.querySelector('input[name="mapping"]');

		const optStr = optInput ? optInput.value.trim() : '';
		const setStr = setInput ? setInput.value.trim() : '';
		const mapStr = mapInput ? mapInput.value.trim() : '';

		if (!topicVal || !name || !typeId || !mapStr) {
			logDebug(`No action! Topic, name, Type or mapping is empty..`);
			return;
		}

		const mapping = {
		  Topic:   topicVal,
		  Name:    name,
		  Type:    typeId
		};

		if (optStr) {
		  try {
			mapping.Options = JSON.parse(optStr);
		  } catch (e) {
			logDebug('Invalid options JSON, skipping:', optStr, e);
		  }
		}

		if (setStr) {
		  try {
			mapping.Set = JSON.parse(setStr);
		  } catch (e) {
			logDebug('Invalid set JSON, skipping:', setStr, e);
		  }
		}

		mapping.Mapping = JSON.parse(mapStr);
		mappings.push(mapping);
	  });

	  //logDebug(`new mappings=${JSON.stringify(mappings)}`);
	  document.getElementById('output').textContent =
		JSON.stringify({ mappings }, null, 2);
	});

  </script>
</body>
</html>
